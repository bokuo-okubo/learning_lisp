;; 13.1 CommonLispでのエラー処理

;; コンディションを通知する
;; 書いた関数の中で、なにかまずいことが起きてしまった時、Lisp関数はlispの実行環境に問題が発生したことを伝える。
;; その手段が、コンディションを通知する、ということ

(error "foo")

;; 自前のコンディションを作る

(define-condition foo () ()
  (:report (lambda (condition stream)
	     (princ "Stop FOOing around, numbskull" stream))))

;; コンディションを横取りする
;; define-conditionでコンデイション型を定義した時に名前を与えた。
;; この名前を使えば、この方のコンディションが通知された時に、プログラムを中断する代わりに実行する処理を、
;; プログラムの上位層で書いておくことができる。
;; そのためのコマンドhandler-case.

(defun bad-function()
  (error 'foo))

(handler-case (bad-function)
	   (foo () "somebody digned foo")
	   (bar () "somebody signed bar"))
;; "somebody digned foo"

;; handler-caseコマンドに最初に与えるのは、横取りしたいコンディションを通知するかもしれないコードだ。この例ではbad-functionの呼び出しがそれにあたる。


;; handler-caseの残りの部分は、特定ノ￥コンディションが通知された時になにをすべきかを並べておく。
;; このコードが実行されると、bad-functionが呼び出される
;; handler-caseがなかったら、この辞典でプログラムが中断されてreplにエラープロンプトが表示されていただろう
;; けど、これではよこどりした

;; 予想外のコンディションからリソースを保護する。

;; 予想外の例外事態が派生した場合、プログラムがクラッシュしたり、ヘタすると外部のリソースを壊したりしてしまうかもしれない。
;; 例外は正しい制御の流れを中断し、重要な竿うさの途中でプログラムの実行が放棄されてしまうかもしれないからだ。

;; 例えばファイルやソケットストリームに何かを書いている最中に例外が発生したとしたとしよう、
;; この時、ストリームを正しくクローズして、ファイルハンドルやソケットを開放してやらないと、それらの資源がずっと使用中のままになってしまうかもしれない。
;; リソースが正しい手順でクリーンアップされないと、
;; そのリソースをユーザが再び使いたい場合はコンピュータをリブートするしかない、ということさえある。

;; この問題を避けるのに使えるのがunwind-protextコマンドだ。
;; このコマンドは、Common Lispコンパイラに、「このコードだけはなにがあっても実行してくれ」と伝えるものだ。

(unwind-protect (/ 1 0)
  (princ "I need to say 'fluybuby' matter what"))
